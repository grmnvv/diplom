DB_URL = 'mongodb://egor:Hooligan28!@localhost:27017/?authMechanism=DEFAULT'
JWTAS = 'RANDOMLY'
JWTRS = 'NOTRANDOMLY'

SMTP_HOST = 'smtp.mail.ru'
SMTP_PORT = '465'
SMTP_USER = 'mcenterspb@internet.ru'
SMTP_PASSWORD = 'wmJhkVFDuiFEmc62EMNh'

RESETLINK = 'kljnfad423s6432jfadkl5634ndv643jhafsd'

import React, { useState, useEffect, useRef } from "react";
import { Stage, Layer, Image, Rect, Circle } from "react-konva";
import useImage from "use-image";
import { v4 as uuidv4 } from "uuid";
import JSZip from "jszip";
import { saveAs } from "file-saver";

const MIN_RECT_SIZE = 20;

const randomColor = () => {
  return "#" + Math.floor(Math.random() * 16777215).toString(16);
};

const ResizeAnchor = ({ x, y, onDragMove }) => {
  return (
    <Circle
      x={x}
      y={y}
      radius={6}
      fill="white"
      stroke="black"
      strokeWidth={1}
      draggable
      onDragMove={onDragMove}
    />
  );
};

const BoundingBox = ({ rect, onDragMove, onResize, onSelect, selected }) => {
  const handleSelect = () => {
    onSelect(rect.id);
  };

  const anchorPositions = [
    { x: "x", y: "y" },
    { x: "x", y: "y", offsetX: "width" },
    { x: "x", y: "y", offsetY: "height" },
    { x: "x", y: "y", offsetX: "width", offsetY: "height" },
  ];

  return (
    <>
      <Rect
        x={rect.x}
        y={rect.y}
        width={rect.width}
        height={rect.height}
        fill={rect.color}
        opacity={selected ? 0.6 : 0.4}
        draggable
        onDragMove={onDragMove}
        onClick={handleSelect}
      />
      {selected && (
        <>
          {anchorPositions.map((point, index) => (
            <ResizeAnchor
              key={index}
              x={rect[point.x] + (point.offsetX ? rect[point.offsetX] : 0)}
              y={rect[point.y] + (point.offsetY ? rect[point.offsetY] : 0)}
              onDragMove={(e) => onResize(e, index)}
            />
          ))}
        </>
      )}
    </>
  );
};

const sendImageToServer = async (image, rect) => {
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  canvas.width = rect.width;
  canvas.height = rect.height;
  ctx.drawImage(
    image,
    rect.x,
    rect.y,
    rect.width,
    rect.height,
    0,
    0,
    rect.width,
    rect.height
  );

  const blob = await new Promise((resolve) =>
    canvas.toBlob(resolve, "image/jpeg")
  );

  const formData = new FormData();
  formData.append("image", blob);

  const response = await fetch("http://localhost:8000/word", {
    method: "POST",
    body: formData,
  });

  if (response.ok) {
    const result = await response.json();
    return result.result;
  } else {
    throw new Error("Ошибка отправки изображения на сервер");
  }
};

const CroppedImage = ({ image, rect, onFilenameChange, filenames }) => {
  const canvasRef = useRef(null);

  useEffect(() => {
    if (!canvasRef.current || !image) return;

    const canvas = canvasRef.current;
    const ctx = canvas.getContext("2d");

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(
      image,
      rect.x,
      rect.y,
      rect.width,
      rect.height,
      0,
      0,
      rect.width,
      rect.height
    );
  }, [image, rect]);

  const handleFilenameChange = (e) => {
    onFilenameChange(rect.id, e.target.value);
  };

  useEffect(() => {
    const fetchResult = async () => {
      try {
        const result = await sendImageToServer(image, rect);
        handleFilenameChange({
          target: { value: result },
        });
      } catch (error) {
        console.error(error);
      }
    };
    fetchResult();
  }, [image, rect]);

  return (
    <div>
      <canvas
        ref={canvasRef}
        width={rect.width}
        height={rect.height}
        style={{ border: "1px solid black" }}
      />
      <p>
        x: {rect.x}, y: {rect.y}, width: {rect.width}, height: {rect.height}
      </p>
      <label>
        Имя файла:
        <input
          type="text"
          value={filenames[rect.id] || ""}
          onChange={handleFilenameChange}
        />
      </label>
    </div>
  );
};

const ImageAnnotation = ({
  imageURL,
  rects: initialRects,
  onRectsChange,
  allCanvasRects,
}) => {
  const [image] = useImage(imageURL);
  const [rects, setRects] = useState(initialRects);
  const [drawing, setDrawing] = useState(false);
  const [currentRect, setCurrentRect] = useState(null);
  const [selectedRectId, setSelectedRectId] = useState(null);
  const rectsRef = useRef(rects);

  const [filenames, setFilenames] = useState({});

  useEffect(() => {
    setRects(initialRects);
  }, [initialRects, imageURL]);

  useEffect(() => {
    if (JSON.stringify(rectsRef.current) !== JSON.stringify(rects)) {
      rectsRef.current = rects;
      onRectsChange(rects);
    }
  }, [rects, onRectsChange]);

  useEffect(() => {
    const updateCroppedImages = () => {
      if (selectedRectId) {
        setRects(rects);
      }
    };
    updateCroppedImages();
  }, [rects, selectedRectId]);

  useEffect(() => {
    const handleKeyDown = (e) => {
      if ((e.key === "Backspace" || e.key === "Delete") && selectedRectId) {
        setRects(rects.filter((rect) => rect.id !== selectedRectId));
        setSelectedRectId(null);
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
    };
  }, [rects, selectedRectId]);

  const saveAllCroppedImages = async () => {
    const zip = new JSZip();
    const folder = zip.folder("all_cropped_images");
    for (const canvasRects of allCanvasRects) {
      for (const rect of canvasRects) {
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        canvas.width = rect.width;
        canvas.height = rect.height;
        ctx.drawImage(
          image,
          rect.x,
          rect.y,
          rect.width,
          rect.height,
          0,
          0,
          rect.width,
          rect.height
        );

        const blob = await new Promise((resolve) =>
          canvas.toBlob(resolve, "image/jpeg")
        );
        folder.file(
          `image_${rect.id}_${filenames[rect.id] || "unnamed"}.jpg`,
          blob
        );
      }
    }
    zip.generateAsync({ type: "blob" }).then((content) => {
      saveAs(content, "all_cropped_images.zip");
    });
  };

  const handleMouseDown = (e) => {
    if (e.target === e.target.getStage()) {
      setDrawing(true);
      const pos = e.target.getPointerPosition();
      const newRect = {
        x: pos.x,
        y: pos.y,
        width: 0,
        height: 0,
        id: uuidv4(),
        color: randomColor(),
      };
      setCurrentRect(newRect);
      setSelectedRectId(newRect.id);
    }
  };

  const handleMouseUp = () => {
    setDrawing(false);
    if (
      currentRect &&
      currentRect.width >= MIN_RECT_SIZE &&
      currentRect.height >= MIN_RECT_SIZE
    ) {
      setRects([...rects, currentRect]);
    }
    setCurrentRect(null);
  };

  const handleMouseMove = (e) => {
    if (!drawing) return;
    const stage = e.target.getStage();
    const pos = stage.getPointerPosition();

    const newWidth = pos.x - currentRect.x;
    const newHeight = pos.y - currentRect.y;

    if (newWidth >= MIN_RECT_SIZE && newHeight >= MIN_RECT_SIZE) {
      setCurrentRect({
        ...currentRect,
        width: newWidth,
        height: newHeight,
      });
    }
  };

  const handleDragMove = (e) => {
    const rectNode = e.target;
    const newRects = rects.map((rect) => {
      if (rect.id === rectNode.attrs.id) {
        return {
          ...rect,
          x: rectNode.attrs.x,
          y: rectNode.attrs.y,
        };
      } else {
        return rect;
      }
    });
    setRects(newRects);
  };

  const handleResize = (e, index) => {
    const anchorNode = e.target;
    const newRects = rects.map((rect) => {
      if (rect.id === selectedRectId) {
        let newWidth = rect.width;
        let newHeight = rect.height;
        let newX = rect.x;
        let newY = rect.y;
        if (index === 0) {
          newWidth += rect.x - anchorNode.attrs.x;
          newHeight += rect.y - anchorNode.attrs.y;
          newX = anchorNode.attrs.x;
          newY = anchorNode.attrs.y;
        } else if (index === 1) {
          newWidth = anchorNode.attrs.x - rect.x;
          newHeight += rect.y - anchorNode.attrs.y;
          newY = anchorNode.attrs.y;
        } else if (index === 2) {
          newWidth += rect.x - anchorNode.attrs.x;
          newHeight = anchorNode.attrs.y - rect.y;
          newX = anchorNode.attrs.x;
        } else if (index === 3) {
          newWidth = anchorNode.attrs.x - rect.x;
          newHeight = anchorNode.attrs.y - rect.y;
        }

        if (newWidth >= MIN_RECT_SIZE && newHeight >= MIN_RECT_SIZE) {
          return {
            ...rect,
            width: newWidth,
            height: newHeight,
            x: newX,
            y: newY,
          };
        } else {
          return rect;
        }
      } else {
        return rect;
      }
    });
    setRects(newRects);
  };

  return (
    <div>
      <Stage
        width={image ? image.width : 0}
        height={image ? image.height : 0}
        onMouseDown={handleMouseDown}
        onMouseUp={handleMouseUp}
        onMouseMove={handleMouseMove}
      >
        <Layer>
          <Image image={image} />
          {rects.map((rect) => (
            <BoundingBox
              key={rect.id}
              rect={rect}
              onDragMove={handleDragMove}
              onResize={handleResize}
              onSelect={setSelectedRectId}
              selected={rect.id === selectedRectId}
            />
          ))}
          {currentRect && (
            <Rect
              x={currentRect.x}
              y={currentRect.y}
              width={currentRect.width}
              height={currentRect.height}
              fill={currentRect.color}
              opacity={0.4}
            />
          )}
        </Layer>
      </Stage>
      <button onClick={saveAllCroppedImages}>
        Сохранить все выделенные изображения
      </button>
      <div>
        {rects.map((rect) => (
          <CroppedImage
            key={rect.id}
            image={image}
            rect={rect}
            onFilenameChange={(id, filename) => {
              setFilenames({ ...filenames, [id]: filename });
            }}
            filenames={filenames}
          />
        ))}
      </div>
    </div>
  );
};

export default ImageAnnotation;
